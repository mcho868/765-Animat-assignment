1. Implementation

The animat simulation is a Python 3 application utilizing NumPy for numerical tasks, Pygame for 2D visualization, and Matplotlib for plotting evolutionary data. It features a modular design:

**Core Components:**

*   **`core/environment.py`**: Manages the 2D simulation world. It defines `EntityType` (FOOD, WATER, TRAP, ANIMAT) and handles entity placement, collision detection, and provides sensor readings to animats based on proximity to objects within their sensor range.

*   **`agents/base_agent.py`**: Defines the `Animat` class. Animats possess a position, direction, two batteries, and wheel speeds. Their behavior is dictated by a genome (a NumPy array) which encodes parameters for 18 sensorimotor links (9 unique, mirrored for symmetry) and wheel activation thresholds. Key methods include:
    *   `parse_genome`: Translates genome values into functional link parameters.
    *   `compute_wheel_speed`: Calculates wheel speeds based on summed sensorimotor link outputs, which are processed through a sigmoid function. Link outputs themselves are influenced by sensor values and battery levels.
    *   `move`: Updates position/direction based on wheel speeds.
    *   `get_fitness`: Fitness is derived from remaining battery levels, normalized.

*   **`agents/agent_logic.py`**: Implements the `GeneticAlgorithm` (GA). This class handles:
    *   `initialize_population`: Creates random genomes.
    *   `evaluate_fitness`: Assesses each genome by simulating an animat and recording its fitness. The `simulate_animat` helper function performs this simulation.
    *   Evolutionary operators: `tournament_selection` (for parent selection), `crossover` (one-point), and `mutate` (random adjustments to gene values, with elitism ensuring the best genome persists).

*   **`core/simulator.py`**: Orchestrates the simulation. It initializes Pygame (if not headless), the `Environment`, and the `GeneticAlgorithm`. It manages:
    *   The main simulation loop, handling Pygame events, environment updates, and rendering.
    *   `run_evolution_with_visualization`: Simulates and visualizes batches of animats in parallel, dividing the screen for individual views and managing simulation speed versus rendering.
    *   `run_evolution`: Conducts headless evolution.
    *   `plot_stats`: Generates fitness plots using Matplotlib.

*   **`main.py`**: Serves as the application's entry point. It parses command-line arguments (like `--headless`, `--visualize-evolution`), sets up the simulation based on these arguments, and initiates the evolutionary process through the `Simulator`.

*   **`config.py` (inferred)**: Contains default simulation parameters (e.g., population size, mutation rates, environment settings).

**Simplified Execution Flow:**

1.  `main.py` initializes the `Simulator` based on command-line arguments.
2.  If visualizing (`--visualize-evolution`), `Simulator.run_evolution_with_visualization` manages generation-by-generation evolution, simulating and rendering animat batches. Fitness is evaluated, and the GA produces the next generation.
3.  If headless, `Simulator.run_evolution` performs the GA cycle (evaluation, selection, crossover, mutation) without visual output.
4.  Post-evolution, statistics are plotted.

This system evolves animat control genomes, allowing them to interact with their environment, with options for both performance-focused headless runs and insightful visualizations.
